/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */


#include <assert.h>
#include <string.h>

#include "sysinit/sysinit.h"
#include "os/os.h"

#include "bsp.h"

#include <inttypes.h>
#include <mcu/mcu.h>


#include "hal/hal_gpio.h"
#ifdef ARCH_sim
#include "mcu/mcu_sim.h"
#endif

/*LED_BLINK_PIN (PA.0 on the board)*/
#define LED_1            MCU_GPIO_PORTA(0)
/*LED_2 (PA.3 ont the board)*/
#define LED_2            MCU_GPIO_PORTA(3)

/*BUTTON_PIN (PB.8 on the board)*/
#define BUTTON_PIN      MCU_GPIO_PORTB(8)
/*HALL_EFFECT (PA.9 on the board)*/
#define HALL_EFFECT     MCU_GPIO_PORTA(9)


/*Define task stack of the button interruption */
#define MY_TIMER_BUTTON_TASK_PRIO        0
#define MY_TIMER_BUTTON_TASK_STACK_SZ    512

/*Define task stack of the hall efect sensor interruption */
#define MY_TIMER_HALL_TASK_PRIO         20
#define MY_TIMER_HALL_TASK_STACK_SZ     512

/*Callback function for application task event*/
static void my_timer_button_ev_cb(struct os_event *);
static void my_button_ev_cb(struct os_event *);
static void my_timer_hall_ev_cb (struct os_event *);
static void my_hall_ev_cb(struct os_event *);

/*Decalartion of event queue*/
static struct os_eventq my_timer_button_eventq;
static struct os_eventq my_timer_hall_eventq;

static os_stack_t my_timer_button_task_stack[MY_TIMER_BUTTON_TASK_STACK_SZ];
static struct os_task my_timer_button_task_str;

static os_stack_t my_timer_hall_task_stack[MY_TIMER_HALL_TASK_STACK_SZ];
static struct os_task my_timer_hall_task_str;

/* Decalare and initialize the event with the callback function*/
static struct os_event gpio_ev0 = {
    .ev_cb = my_button_ev_cb,
};

static struct os_event gpio_ev1 = {
    .ev_cb = my_hall_ev_cb,
};

/*The timer callout*/
static struct os_callout my_button_callout;
static struct os_callout my_hall_callout;




/* For LED toggling */
int g_led_pin1 = LED_D1;
int g_led_pin2 = LED_D2;

/*Declaration of useful functions*/
static void 
set_LED (int led1)
{
    hal_gpio_write(led1,1);
}

static void 
clear_LED (int led1)
{
    hal_gpio_write(led1,0);
}

static void 
blinker_LED (int led, int tps, int cycle)
{
        int i;
        for (i=0; i<cycle; ++i)
        {
            set_LED(led);
            os_time_delay(tps);
            clear_LED(led);
            os_time_delay(tps);
        }
}


/*Event callback function for button timer events*/
static void my_timer_button_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);
    os_callout_reset(&my_button_callout, OS_TICKS_PER_SEC/100);
}

/*
 * Event callback function for button interrupt event 
 * generated by my_button_irq. It toggles the LED_D1 
 * at pin LED_BLINK_PIN and clear the LED_D2 at 
 * pin LED_2.
 */
static void my_button_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);
    clear_LED(g_led_pin2);
    blinker_LED(g_led_pin1,40,10);
    return;
}
/*Event callback function for hall effect interrupt events*/
static void my_timer_hall_ev_cb(struct os_event *ev)
{
    assert(ev != NULL);
    os_callout_reset(&my_hall_callout, OS_TICKS_PER_SEC/100);    
}

/*
 * Event callback function for hall efect interrupt 
 * event generated by my_hall_irq. It set the LED_D2 
 * at pin LED_2.
 */
static void my_hall_ev_cb(struct os_event *ev)
{
    assert(ev!=NULL);
    set_LED(g_led_pin2);
    //clear_LED(g_led_pin1);
}

/*
 * Implementation of the interrupt task in the different
 * event queue
 */
static void
my_button_irq(void *arg)
{
    os_eventq_put(&my_timer_button_eventq, &gpio_ev0);
}
static void
my_timer_button_task(void *arg)
{
    while (1) 
    {
        os_eventq_run(&my_timer_button_eventq);
    }
}
static void 
my_hall_irq(void *arg)
{
    os_eventq_put(&my_timer_hall_eventq, &gpio_ev1);
}
static void
my_timer_hall_task(void *arg)
{
    while(1)
    {
        os_eventq_run(&my_timer_hall_eventq);
    }
}

void
init_tasks(void)
{
    /* Use a dedicate event queue for timer and interrupt events */
    os_eventq_init(&my_timer_button_eventq);     
    os_eventq_init(&my_timer_hall_eventq);

    /* 
     * Create the task to process timers and interrupts events from 
     * the my_timer_button_eventq event queue and the 
     * my_timer_hall_eventq.
     */
    os_task_init(&my_timer_button_task_str, "timer_button_task", 
                 my_timer_button_task, NULL, 
                 MY_TIMER_BUTTON_TASK_PRIO, OS_WAIT_FOREVER, 
                 my_timer_button_task_stack, 
                 MY_TIMER_BUTTON_TASK_STACK_SZ);
    

    os_task_init(&my_timer_hall_task_str, "timer_hall_task", 
                 my_timer_hall_task, NULL, 
                 MY_TIMER_HALL_TASK_PRIO, OS_WAIT_FOREVER, 
                 my_timer_hall_task_stack, 
                 MY_TIMER_HALL_TASK_STACK_SZ);

    /* 
     * Initialize the callout for a timer event.  
     * The my_timer_ev_cb callback function processes the timer event.
     */
    os_callout_init(&my_button_callout, &my_timer_button_eventq,  
                    my_timer_button_ev_cb, NULL);

    os_callout_reset(&my_button_callout, OS_TICKS_PER_SEC);

    os_callout_init(&my_hall_callout, &my_timer_hall_eventq, 
                    my_timer_hall_ev_cb, NULL);
    os_callout_reset(&my_hall_callout, OS_TICKS_PER_SEC);


    /* 
     * Initialize and enable interrupt for the pin for the push button
     * and the hall effect sensor and configure the button and the hall
     * effect sensor with pull up resistor on the mcu.
     */ 
    
    hal_gpio_irq_init(BUTTON_PIN, my_button_irq, NULL, 
                         HAL_GPIO_TRIG_FALLING, HAL_GPIO_PULL_UP);
    hal_gpio_irq_enable(BUTTON_PIN);

    hal_gpio_irq_init(HALL_EFFECT, my_hall_irq, NULL,
                         HAL_GPIO_TRIG_FALLING, HAL_GPIO_PULL_UP);
    hal_gpio_irq_enable(HALL_EFFECT);


    hal_gpio_init_out(LED_D1, 0);
    hal_gpio_init_out(LED_D2, 0);
}


/* Declaration of the main of the code */
int
main(int argc, char **argv)
{
    int rc;

#ifdef ARCH_sim
    mcu_sim_parse_args(argc, argv);
#endif

    sysinit();
    init_tasks();

    while(1)
    {
        os_eventq_run(os_eventq_dflt_get());
    }
    assert(0);
    return rc;
}
